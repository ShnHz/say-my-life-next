import{_ as t,o as a,c as r,S as c}from"./chunks/framework.7114eebe.js";const u=JSON.parse('{"title":"TypeScript","description":"","frontmatter":{"title":"TypeScript","config":{"dir":true},"password":true},"headers":[],"relativePath":"views/interview/TypeScript.md","filePath":"views/interview/TypeScript.md"}'),s={name:"views/interview/TypeScript.md"};function i(o,e,p,d,n,l){return a(),r("div",null,e[0]||(e[0]=[c('<h3 id="typescript" tabindex="-1">TypeScript <a class="header-anchor" href="#typescript" aria-label="Permalink to &quot;TypeScript&quot;">​</a></h3><h4 id="_1-ts的原理-为什么会有ts" tabindex="-1">1.TS的原理？为什么会有TS？ <a class="header-anchor" href="#_1-ts的原理-为什么会有ts" aria-label="Permalink to &quot;1.TS的原理？为什么会有TS？&quot;">​</a></h4><p>ts就是js的超集，ts在js的基础上对数据类型进行约束产生的一种新语言，使得代码更加规范，相比于js来说，ts在攥写代码/编译过程中就能够发现错误，而防止在产品上线后发生一些莫名其妙的问题。</p><h4 id="_2-interface和type的区别是什么" tabindex="-1">2.interface和type的区别是什么？ <a class="header-anchor" href="#_2-interface和type的区别是什么" aria-label="Permalink to &quot;2.interface和type的区别是什么？&quot;">​</a></h4><p>两者的作用都是一样的，都是定义一个类型别名（接口），但是扩展接口的方式有所不同，<code class="default">interface</code>可以用<code class="default">extends</code>，<code class="default">type</code>用<code class="default">&amp;</code>，如果定义同名的接口，<code class="default">interface</code>会合并两者，<code class="default">type</code>不允许定义同名的类型别名</p>',5)]))}const h=t(s,[["render",i]]);export{u as __pageData,h as default};
