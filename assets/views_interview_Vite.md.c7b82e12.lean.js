import{_ as t,o as a,c as i,S as o}from"./chunks/framework.7114eebe.js";const p=JSON.parse('{"title":"Vite","description":"","frontmatter":{"title":"Vite","config":{"dir":true},"password":true},"headers":[],"relativePath":"views/interview/Vite.md","filePath":"views/interview/Vite.md"}'),l={name:"views/interview/Vite.md"};function s(d,e,c,r,n,u){return a(),i("div",null,e[0]||(e[0]=[o('<h3 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h3><h4 id="_1-说一下vite" tabindex="-1">1.说一下Vite？ <a class="header-anchor" href="#_1-说一下vite" aria-label="Permalink to &quot;1.说一下Vite？&quot;">​</a></h4><p><code class="default">vite</code> 其实也是一个前端工具，它的出现原因呢是因为当我们构建的项目越来越大的时候，需要处理的js也越来越多，那么传统的那些工具呢就会遇到性能瓶颈；通常需要好长时间才能够启动项目/打包项目，这个时候呢 <code class="default">vite</code> 也就应运而生，利用了浏览器所支持的一些最新的ES模块，解决以上的一些问题。</p><h5 id="缓慢的服务器启动" tabindex="-1">缓慢的服务器启动 <a class="header-anchor" href="#缓慢的服务器启动" aria-label="Permalink to &quot;缓慢的服务器启动&quot;">​</a></h5><p><code class="default">Vite</code> 通过在一开始将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码</strong> 两类，改进了开发服务器启动时间。</p><ul><li><strong>依赖</strong> 是大多在开发时不会变动的js，vite会使用esbuild预构建依赖，esbuild使用Go编写，所以会比使用js编写的打包器快上10-100倍</li><li><strong>源码</strong> 通常包含一些不只是js的文件，比如css、jsx、vue等等，时常会被编辑。vite以元素ESM方式提供源码。这其实是让浏览器接管了打包程序的工作：vite只需要在浏览器请求源码的时候提供源码即可。根据情景动态导入代码，即只在当前屏幕内实际运用时才会被处理。</li></ul><h5 id="缓慢的更新" tabindex="-1">缓慢的更新 <a class="header-anchor" href="#缓慢的更新" aria-label="Permalink to &quot;缓慢的更新&quot;">​</a></h5><p>在 <code class="default">Vite</code> 中，<code class="default">HMR（热更新）</code> 是在原生 ESM 上执行的。当编辑一个文件时，<code class="default">Vite</code> 只需要精确地使已编辑的模块与其最近的 <code class="default">HMR</code> 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，<code class="default">HMR</code> 始终能保持快速更新。</p><p><code class="default">Vite</code> 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p><h4 id="_2-利用了es的什么新规范才使得它能够得到效果" tabindex="-1">2.利用了ES的什么新规范才使得它能够得到效果？ <a class="header-anchor" href="#_2-利用了es的什么新规范才使得它能够得到效果" aria-label="Permalink to &quot;2.利用了ES的什么新规范才使得它能够得到效果？&quot;">​</a></h4><p><code class="default">es module</code>：ES6的模块化规范</p><ul><li>默认开启严格模式；</li><li>import</li><li>export</li><li>default export</li></ul><p>因为传统的方式是将所有的路由，代码文件全部打包为<code class="default">bundle</code>，再传递给浏览器进行启动，<code class="default">vite</code>呢其实是利用<code class="default">esm</code>规范直接将各个模块发送给浏览器，没有了打包的这一阶段，所以快很多。</p><p>利用这个规范让浏览器自己去加载依赖，也就是把压力丢给了浏览器，从而达到了项目启动速度快的效果。</p>',14)]))}const h=t(l,[["render",s]]);export{p as __pageData,h as default};
