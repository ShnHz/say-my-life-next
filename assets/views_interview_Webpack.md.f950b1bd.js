import{_ as a,o as l,c,S as s}from"./chunks/framework.7114eebe.js";const u=JSON.parse('{"title":"Webpack","description":"","frontmatter":{"title":"Webpack","config":{"dir":true},"password":true},"headers":[],"relativePath":"views/interview/Webpack.md","filePath":"views/interview/Webpack.md"}'),t={name:"views/interview/Webpack.md"};function i(o,e,r,d,n,p){return l(),c("div",null,e[0]||(e[0]=[s('<h3 id="webpack" tabindex="-1">Webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;Webpack&quot;">​</a></h3><h4 id="_1-webpack-是什么-作用呢" tabindex="-1">1.Webpack 是什么？作用呢？ <a class="header-anchor" href="#_1-webpack-是什么-作用呢" aria-label="Permalink to &quot;1.Webpack 是什么？作用呢？&quot;">​</a></h4><p><code class="default">webpack</code>其实就是一个代码编译工具，集成了很多很多功能，其中几个主要的功能就是<strong>模块打包</strong>、<strong>编译兼容</strong>、<strong>能力扩展</strong></p><h5 id="模块打包" tabindex="-1">模块打包 <a class="header-anchor" href="#模块打包" aria-label="Permalink to &quot;模块打包&quot;">​</a></h5><p>就是可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序，并且对文件做一些混淆压缩等功能。</p><h5 id="编译兼容" tabindex="-1">编译兼容 <a class="header-anchor" href="#编译兼容" aria-label="Permalink to &quot;编译兼容&quot;">​</a></h5><p>就是把写的高版本代码，解析成低版本兼容的代码，从而减少工作量以及提高兼容性。同时把一些预编译文件编译为浏览器能够识别的代码格式，比如 <code class="default">scss =&gt; css</code> ，<code class="default">vue =&gt; html/js/css</code>，<code class="default">jsx =&gt; html/js</code></p><h5 id="能力扩展" tabindex="-1">能力扩展 <a class="header-anchor" href="#能力扩展" aria-label="Permalink to &quot;能力扩展&quot;">​</a></h5><p>通过<code class="default">webpack</code>的<code class="default">plugin</code>机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化工程化的程度。</p><h4 id="_2-webpack-loader和plugin的区别" tabindex="-1">2.Webpack Loader和Plugin的区别？ <a class="header-anchor" href="#_2-webpack-loader和plugin的区别" aria-label="Permalink to &quot;2.Webpack Loader和Plugin的区别？&quot;">​</a></h4><p>loader就是加载器，plugin就是插件</p><p>loader：用来转换（翻译）文件，比如把ES6转换为ES5，把SASS转换为CSS，把TS转换为JS</p><p>plugin：扩展webpack的功能，比如说压缩文件，打包优化，设置一些环境变量等等</p><h4 id="_3-如何优化webpack打包的速度" tabindex="-1">3.如何优化webpack打包的速度？ <a class="header-anchor" href="#_3-如何优化webpack打包的速度" aria-label="Permalink to &quot;3.如何优化webpack打包的速度？&quot;">​</a></h4><ul><li>1.多进程构建（资源并行解析），构建过程中，我们需要使用loader对一些代码、文件、图片进行解析，那把这些解析过程做成并发就会大大提高速度。（thread-loader）</li><li>2.多进程压缩，和构建一样，压缩过程也可以并发达到优化速度的目的。</li><li>3.利用CDN，可以把一些大的依赖引入CDN。</li><li>4.利用缓存，使用cache-loader缓存文件。</li></ul><h4 id="_4-如果有个项目-你需要考虑他的缓存机制-应该是怎么样的。js-css-html分别都需要做什么缓存" tabindex="-1">4.如果有个项目，你需要考虑他的缓存机制，应该是怎么样的。js/css/html分别都需要做什么缓存？ <a class="header-anchor" href="#_4-如果有个项目-你需要考虑他的缓存机制-应该是怎么样的。js-css-html分别都需要做什么缓存" aria-label="Permalink to &quot;4.如果有个项目，你需要考虑他的缓存机制，应该是怎么样的。js/css/html分别都需要做什么缓存？&quot;">​</a></h4><p><code class="default">js</code>文件比较大，可以做协商缓存；<code class="default">css/html</code>文件相应的比较小，可以做强缓存。</p><p>但其实也要根据项目的具体需求，具体业务去做计划。</p><h4 id="_5-npm-run-dev-执行过程" tabindex="-1">5.npm run dev 执行过程 <a class="header-anchor" href="#_5-npm-run-dev-执行过程" aria-label="Permalink to &quot;5.npm run dev 执行过程&quot;">​</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">npm run dev</span></span></code></pre></div><p><code class="default">dev</code> 其实是一个写在配置文件的脚本命令，这边可以修改为任何值</p><p>它所执行的代码是 vue3 <code class="default">vite</code> ，vue2 <code class="default">vue-cli-service serve</code></p><h4 id="_6-webpack配置优化" tabindex="-1">6.Webpack配置优化 <a class="header-anchor" href="#_6-webpack配置优化" aria-label="Permalink to &quot;6.Webpack配置优化&quot;">​</a></h4><ul><li>1.按需引入@babel/polyfill</li><li>2.alias通过创建import或者require的别名</li><li>3.减少打包文件</li><li>4.提取公共代码</li><li>5.externals排除CDN文件</li><li>6.Tree Shaking，将死代码剔除</li><li>7.运用缓存，cache-loader</li><li>8.多进程配置，解析js、css、图片、字体等等</li></ul>',24)]))}const b=a(t,[["render",i]]);export{u as __pageData,b as default};
