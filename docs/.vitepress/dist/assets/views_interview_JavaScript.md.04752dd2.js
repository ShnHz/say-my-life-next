import{_ as a,c as s,o as l,V as e}from"./chunks/framework.f518e559.js";const D=JSON.parse('{"title":"JavaScript","description":"","frontmatter":{"title":"JavaScript","config":{"dir":true},"password":true},"headers":[],"relativePath":"views/interview/JavaScript.md"}'),o={name:"views/interview/JavaScript.md"},n=e(`<h3 id="八股文" tabindex="-1">八股文 <a class="header-anchor" href="#八股文" aria-label="Permalink to &quot;八股文&quot;">​</a></h3><h4 id="_1-说一说你对闭包的理解" tabindex="-1">1.说一说你对闭包的理解？ <a class="header-anchor" href="#_1-说一说你对闭包的理解" aria-label="Permalink to &quot;1.说一说你对闭包的理解？&quot;">​</a></h4><p>闭包就是js的一个语法特性,闭包就是一个<b>“背包”</b>，所有js的函数都有一个背包，这个背包里面装的就是一些<b>函数体内调用的外层作用域的变量</b>。</p><p>闭包的原理：作用域链，当前作用域可以访问上级作用域的变量。</p><p>闭包的作用：</p><ul><li>私有化变量，能够使函数外部访问函数内部的局部变量</li><li>延长变量的生命周期</li><li>封装一个类</li></ul><p>带来的问题：造成内存泄漏，因为浏览器不会销毁这些闭包变量。</p><p>可以参考我的文章 <a href="https://www.sanghangning.cn/views/blog/js/Closure.html" target="_blank" rel="noreferrer">如何理解JS闭包？</a></p><h4 id="_2-说一说new会发生什么" tabindex="-1">2.说一说new会发生什么？ <a class="header-anchor" href="#_2-说一说new会发生什么" aria-label="Permalink to &quot;2.说一说new会发生什么？&quot;">​</a></h4><p>步骤如下：</p><ul><li>创建一个新对象</li><li>将新对象的隐式原型<code>_<em>proto</em>_</code>指向构造函数的原型对象<code>prototype</code></li><li>利用<code>apply</code>或者<code>call</code>方法将新对象以及参数传入，执行构造函数</li><li>返回新对象</li></ul><p>可以参考我的文章 <a href="https://www.sanghangning.cn/views/blog/js/New.html" target="_blank" rel="noreferrer">JS的new操作符</a></p><h4 id="_3-如何理解原型链" tabindex="-1">3.如何理解原型链？ <a class="header-anchor" href="#_3-如何理解原型链" aria-label="Permalink to &quot;3.如何理解原型链？&quot;">​</a></h4><p>在js中，所有对象都有一个隐式原型<code><strong>proto</strong></code>，而且js万物都是对象。所以就会有一条由<code><strong>proto</strong></code>组成的链条，这条链条就叫原型链。这个链条最终的值是<code>null</code>，因为<code>Object.prototype.<strong>proto</strong></code>为<code>null</code></p><p>一个实例的隐式原型<code><strong>proto</strong></code>指向构造函数的显式原型<code>prototype</code></p><p>可以参考我的文章 <a href="https://www.sanghangning.cn/views/blog/js/Prototype.html" target="_blank" rel="noreferrer">JS的原型/原型链</a></p><h4 id="_4-如何理解this" tabindex="-1">4.如何理解this？ <a class="header-anchor" href="#_4-如何理解this" aria-label="Permalink to &quot;4.如何理解this？&quot;">​</a></h4><p>函数在调用的时候会创建一个执行环境，<code>this</code>对象基于这个执行环境绑定，所以<code>this</code>的指向其实就是基于函数的执行环境决定的。</p><p>可以参考我的文章 <a href="https://www.sanghangning.cn/views/blog/js/This.html" target="_blank" rel="noreferrer">JS的this指向问题</a></p><h4 id="_5-js中的继承有哪几种" tabindex="-1">5.js中的继承有哪几种？ <a class="header-anchor" href="#_5-js中的继承有哪几种" aria-label="Permalink to &quot;5.js中的继承有哪几种？&quot;">​</a></h4><ul><li>构造函数继承</li><li>原型链继承</li><li>组合继承</li><li>寄生继承</li><li>寄生组合继承</li><li>Class继承<code>extend</code></li></ul><p>可以参考我的文章 <a href="https://www.sanghangning.cn/views/blog/js/Inherit.html" target="_blank" rel="noreferrer">JS中常用的继承方式</a></p><h4 id="_6-js有哪些数据类型-他们有什么不同" tabindex="-1">6.js有哪些数据类型？他们有什么不同？ <a class="header-anchor" href="#_6-js有哪些数据类型-他们有什么不同" aria-label="Permalink to &quot;6.js有哪些数据类型？他们有什么不同？&quot;">​</a></h4><p>基本数据类型：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>，es6新增的<code>BigInt</code>、<code>Symbol</code></p><p>引用数据类型：<code>Object</code>，<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>其实都是对象。</p><p>基本数据类型存储在内存栈中，占用空间小。</p><p>引用数据类型存储在内存堆中，占用空间大，而且存储了一个指针在内存栈中。</p><h4 id="_7-为什么0-1-0-2-0-3-如何让其相等" tabindex="-1">7.为什么0.1+0.2!==0.3，如何让其相等？ <a class="header-anchor" href="#_7-为什么0-1-0-2-0-3-如何让其相等" aria-label="Permalink to &quot;7.为什么0.1+0.2!==0.3，如何让其相等？&quot;">​</a></h4><p>因为进制转换对阶过程中会出现精度缺失问题。浮点数转成二进制时丢失了精度，因此在二进制转十进制过程中可能会出现结果不符的情况。</p><p>在计算前先将数字乘以一个10的幂次数。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">(0.1*10+0.2*10)/10 //0.3</span></span></code></pre></div><h4 id="_8-let、const、var的区别" tabindex="-1">8.let、const、var的区别？ <a class="header-anchor" href="#_8-let、const、var的区别" aria-label="Permalink to &quot;8.let、const、var的区别？&quot;">​</a></h4><ul><li>块级作用域：<code>let</code>、<code>const</code>有块级作用域的特性,<code>var</code>没有。</li><li>变量提升：<code>let</code>、<code>const</code>不会变量提升，<code>var</code>会，其实<code>let</code>也是会的，只是由于暂时性死区的缘故，不能在声明前使用这个变量。</li><li>常量：<code>const</code>声明后不可改变。</li><li>全局属性：浏览器的全局是<code>windows</code>，nodejs的全局是<code>global</code><code>var</code>声明的变量为全局变量，并且会将该变量添加到全局属性上。</li><li>重复声明： <code>var</code>是可以被重复声明的，会覆盖前一个声明的变量，<code>let</code>、<code>const</code>重复声明会报错。</li><li>初始值：<code>let</code>、<code>val</code>可以声明时不赋值，<code>const</code>不赋值则会报错。</li><li>暂时性死区：在使用<code>let</code>、<code>const</code>时，声明前都是不可以使用这个对象的。</li></ul><h4 id="_9-什么是变量提升-变量提升默认值为什么是undefined" tabindex="-1">9.什么是变量提升？变量提升默认值为什么是undefined？ <a class="header-anchor" href="#_9-什么是变量提升-变量提升默认值为什么是undefined" aria-label="Permalink to &quot;9.什么是变量提升？变量提升默认值为什么是undefined？&quot;">​</a></h4><p>变量提升就是指将声明对象语句执行顺序提升到作用域最上方，<code>var</code>有变量提升的特性，<code>let</code>、<code>const</code>没有。</p><p>因为变量提升只提升变量的声明语句，不提升赋值语句，声明了变量没有赋值的话就是<code>undefined</code>。</p><h4 id="_10-this的指向问题" tabindex="-1">10.this的指向问题？ <a class="header-anchor" href="#_10-this的指向问题" aria-label="Permalink to &quot;10.this的指向问题？&quot;">​</a></h4><ul><li>new调用（new Methods()）：绑定到<code>new</code>出来的对象上。</li><li>普通函数调用（methods()）：严格模式下为<code>undefined</code>，混杂模式下为全局对象。</li><li>对象调用（obj.methods()）：绑定到<code>obj</code>上，也就是调用的对象上。</li><li>call、apply、bind：由传入参数决定，因为这三个函数都是改变<code>this</code>指向的作用。</li><li>箭头函数：箭头函数本身没有<code>this</code>，所以继承的是上级作用域的<code>this</code>。</li></ul><p>可以参考我的文章 <a href="https://www.sanghangning.cn/views/blog/js/This.html" target="_blank" rel="noreferrer">JS的this指向问题</a></p><h4 id="_11-bind、call和apply的区别" tabindex="-1">11.bind、call和apply的区别？ <a class="header-anchor" href="#_11-bind、call和apply的区别" aria-label="Permalink to &quot;11.bind、call和apply的区别？&quot;">​</a></h4><p>它们的功能完全一样，都是改变<code>this</code>的指向，唯一的区别是传入参数不同。</p><p>第一个参数是指定了函数体内的this指向，后面的参数有所不同。</p><p><code>call</code>传入的是多个对象，以顺序依此传入对象。</p><p><code>apply</code>传入的是一个对象数组。</p><p><code>bind</code>与<code>call</code>、<code>apply</code>的使用方式不同，<code>call</code>、<code>apply</code>会直接执行函数，<code>bind</code>则会返回一个新的函数。</p><p><a href="https://www.sanghangning.cn/views/blog/js/BindCallApply.html" target="_blank" rel="noreferrer">JS手写bind、call、apply</a></p><h4 id="_12-说一说js有什么判断变量类型的方法" tabindex="-1">12.说一说js有什么判断变量类型的方法？ <a class="header-anchor" href="#_12-说一说js有什么判断变量类型的方法" aria-label="Permalink to &quot;12.说一说js有什么判断变量类型的方法？&quot;">​</a></h4><ul><li>instandof:无法判断数组和对象</li><li>typeof:基本数据类型判断，无法判断引用类型</li><li>Object.prototype.tostring.call():所有类型都能够判断</li><li>Array.isArray():判断是否为数组</li></ul><h4 id="_13-说一说js实现异步的方法" tabindex="-1">13.说一说js实现异步的方法？ <a class="header-anchor" href="#_13-说一说js实现异步的方法" aria-label="Permalink to &quot;13.说一说js实现异步的方法？&quot;">​</a></h4><ul><li>promise</li><li>await/async</li><li>生成器函数 Generator/yield</li><li>计时器</li><li>回调函数</li></ul><h4 id="_14-说一下eventloop-事件循环" tabindex="-1">14.说一下EventLoop（事件循环）？ <a class="header-anchor" href="#_14-说一下eventloop-事件循环" aria-label="Permalink to &quot;14.说一下EventLoop（事件循环）？&quot;">​</a></h4><p>由于js是单线程的，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件，那么要让这些事件能够有条不紊的进行就需要一个统筹管理系统，其实就是<code>eventloop</code>（事件循环）。</p><p>js的任务分为同步任务以及异步任务，处理机制总结起来是这样的，先执行同步任务，再执行异步任务，异步任务又分为微任务以及宏任务，先执行微任务再执行宏任务。</p><p>常见宏任务：setTimeout，setInterval，DOM事件，script标签，ajax 常见微任务：Promise，async/await</p><h4 id="_15-说一说-null-和-undefined-的区别" tabindex="-1">15.说一说 null 和 undefined 的区别? <a class="header-anchor" href="#_15-说一说-null-和-undefined-的区别" aria-label="Permalink to &quot;15.说一说 null 和 undefined 的区别?&quot;">​</a></h4><ul><li><code>null</code>是定义了并赋值<code>null</code></li><li><code>undefined</code>定义未赋值</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">//true</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">//false</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">!null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!undefined</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">//true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">//1</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">//NAN</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">//1</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">//NAN</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> []) </span><span style="color:#676E95;font-style:italic;">//null</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> []) </span><span style="color:#676E95;font-style:italic;">//undefined</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">undefined,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null}</span><span style="color:#A6ACCD;">))  </span><span style="color:#676E95;font-style:italic;">// &#39;{b: null}&#39;)</span></span></code></pre></div><h4 id="_16-事件委托的原理" tabindex="-1">16.事件委托的原理？ <a class="header-anchor" href="#_16-事件委托的原理" aria-label="Permalink to &quot;16.事件委托的原理？&quot;">​</a></h4><p><strong>事件委托</strong>也称为<strong>事件代理</strong>。就是利用<strong>事件冒泡</strong>，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p><p>其实就是比如说有100个按钮，每个按钮都要绑定相同的单击事件，那么不如直接把事件绑定在包裹这100个按钮的容器上</p><p>优点：</p><ul><li>替代循环绑定事件的操作，减少内存消耗，提高性能。</li><li>简化dom节点更新的时候，在新dom上再次绑定事件的性能消耗</li></ul><p>缺点：</p><ul><li>对于不冒泡的事件无法委托</li><li>层级过多时，可能会被某一级阻止</li><li>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托</li></ul><h5 id="事件委托的顺序" tabindex="-1">事件委托的顺序？ <a class="header-anchor" href="#事件委托的顺序" aria-label="Permalink to &quot;事件委托的顺序？&quot;">​</a></h5><p>dom元素中，既有冒泡，又有捕获的执行顺序：w3c规定，任何发生在w3c事件模型中的事件，<strong>首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</strong>。</p><h4 id="_17-深拷贝-浅拷贝" tabindex="-1">17.深拷贝？浅拷贝？ <a class="header-anchor" href="#_17-深拷贝-浅拷贝" aria-label="Permalink to &quot;17.深拷贝？浅拷贝？&quot;">​</a></h4><p>深拷贝比如说一个对象想要拷贝，就是在内存堆中重新开辟一块空间出来进行拷贝对象的存储，而浅拷贝只是拷贝了原对象在内存堆中的一个指针，实际上存储的还是原对象。</p><h4 id="_18-object-assign-是深拷贝吗" tabindex="-1">18.Object.assign()是深拷贝吗？ <a class="header-anchor" href="#_18-object-assign-是深拷贝吗" aria-label="Permalink to &quot;18.Object.assign()是深拷贝吗？&quot;">​</a></h4><p>可以是深拷贝也可以是浅拷贝，当传递对象为基本类型时，是浅拷贝，传递对象为引用类型时，是深拷贝，当对象有二级属性时候，也是浅拷贝（对象内有对象）</p><h4 id="_19-instandof-的原理" tabindex="-1">19.instandof 的原理？ <a class="header-anchor" href="#_19-instandof-的原理" aria-label="Permalink to &quot;19.instandof 的原理？&quot;">​</a></h4><p>就是对比左侧对象的原型链与右侧对象的显式原型prototype，看看是否存在右侧的这个显式原型，如果是则返回true，否则返回false</p><h4 id="_20-说一说es6的箭头函数" tabindex="-1">20.说一说es6的箭头函数？ <a class="header-anchor" href="#_20-说一说es6的箭头函数" aria-label="Permalink to &quot;20.说一说es6的箭头函数？&quot;">​</a></h4><p>是创建函数的语法糖 没有this 继承上个作用域的this，没有argments，没有new，没有prototype</p><h4 id="_21-1-2-3-0x16-map-parseint-输出什么" tabindex="-1">21.[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;0x16&#39;].map(parseInt)输出什么 <a class="header-anchor" href="#_21-1-2-3-0x16-map-parseint-输出什么" aria-label="Permalink to &quot;21.[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;0x16&#39;].map(parseInt)输出什么&quot;">​</a></h4><p>-&gt;parseInt&lt;-方法当str以-&gt;0x&lt;-开头，则按照16进制处理，其余情况都以10进制处理</p><h4 id="_22-es6有哪些常用的功能" tabindex="-1">22.ES6有哪些常用的功能 <a class="header-anchor" href="#_22-es6有哪些常用的功能" aria-label="Permalink to &quot;22.ES6有哪些常用的功能&quot;">​</a></h4><ul><li>箭头函数</li><li>解构</li><li>set、map</li><li>let、const变量命名</li><li>promise、generator、await/async</li><li>模板字符串</li><li>新的变量类型bigint、symol</li><li>import\\export模块化 ESM</li><li>函数参数的默认值</li></ul><h4 id="_23-echarts部分有没有配置比较复杂的图" tabindex="-1">23.echarts部分有没有配置比较复杂的图 <a class="header-anchor" href="#_23-echarts部分有没有配置比较复杂的图" aria-label="Permalink to &quot;23.echarts部分有没有配置比较复杂的图&quot;">​</a></h4><p>世界地图，鼠标hover显示自定义的html面板展示一些柱状图数据</p><h4 id="_24-typeof-nan-的结果是什么" tabindex="-1">24.typeof NaN 的结果是什么 <a class="header-anchor" href="#_24-typeof-nan-的结果是什么" aria-label="Permalink to &quot;24.typeof NaN 的结果是什么&quot;">​</a></h4><p>number</p><h4 id="_25-isnan-和-number-isnan-函数的区别" tabindex="-1">25.isNaN 和 Number.isNaN 函数的区别？ <a class="header-anchor" href="#_25-isnan-和-number-isnan-函数的区别" aria-label="Permalink to &quot;25.isNaN 和 Number.isNaN 函数的区别？&quot;">​</a></h4><p>isNaN函数会首先进行number函数转换，如果转换后为number类型，则返回false，否则返回true</p><p>Number.isNaN函数是严格等于NaN，不做任何转换，只有NaN返回true</p><h4 id="_26-map和weakmap的区别" tabindex="-1">26.map和weakMap的区别 <a class="header-anchor" href="#_26-map和weakmap的区别" aria-label="Permalink to &quot;26.map和weakMap的区别&quot;">​</a></h4><ul><li>Map的键可以是任意类型，WeakMap只接受对象作为键，不接受其它类型的值作为键</li><li>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键；WeakMap的键是弱引用，键所指向的对象是可以被垃圾回收，此时键是无效的。</li><li>Map可以被遍历，WeakMap不能被遍历</li></ul><h4 id="_27-for-in-和for-of-的区别" tabindex="-1">27.for in 和for of 的区别 <a class="header-anchor" href="#_27-for-in-和for-of-的区别" aria-label="Permalink to &quot;27.for in 和for of 的区别&quot;">​</a></h4><ul><li>for in可以遍历对象，for of不能遍历对象</li><li>for of可以用来遍历map集合，for in不能遍历map集合</li><li>for in遍历数组得到的是数组的下标，for of遍历数组得到的是数组的元素</li><li>for in遍历键，for of遍历值</li></ul><h4 id="_28-为什么for-of不能遍历对象" tabindex="-1">28.为什么for of不能遍历对象 <a class="header-anchor" href="#_28-为什么for-of不能遍历对象" aria-label="Permalink to &quot;28.为什么for of不能遍历对象&quot;">​</a></h4><p>因为对象没有实现-&gt;Symbol.iterator&lt;-这个方法，就是迭代器</p><h4 id="_29-es5和es6的继承-这两种方式除了写法-还有其他区别吗" tabindex="-1">29.ES5和ES6的继承? 这两种方式除了写法, 还有其他区别吗? <a class="header-anchor" href="#_29-es5和es6的继承-这两种方式除了写法-还有其他区别吗" aria-label="Permalink to &quot;29.ES5和ES6的继承? 这两种方式除了写法, 还有其他区别吗?&quot;">​</a></h4><p>es6的Class本质上是个语法糖,就是es5的寄生组合式继承的语法糖,所以其实没有什么区别</p><h3 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h3><h4 id="_1-说一说promise是什么" tabindex="-1">1.说一说promise是什么？ <a class="header-anchor" href="#_1-说一说promise是什么" aria-label="Permalink to &quot;1.说一说promise是什么？&quot;">​</a></h4><p>promise诞生是为了解决回调地狱的问题，优化代码结构。</p><p>这个单词的意思就是“承诺”，那么一个承诺肯定会有三种状态，等待实现承诺<b>pending</b>、成功<b>fulfilled</b>、失败<b>rejected</b>，且一个承诺是<b>不可逆</b>的</p><h4 id="_2-promise有哪些方法" tabindex="-1">2.promise有哪些方法？ <a class="header-anchor" href="#_2-promise有哪些方法" aria-label="Permalink to &quot;2.promise有哪些方法？&quot;">​</a></h4><ul><li><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的<code>Promise</code>实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被<code>reject</code>失败状态的值。</li><li><code>Promise.race</code>也是传入一个数组，但是是赛跑的意思，顾名思义，就是谁先获得结果，就返回那个结果，不管结果本身是成功状态还是失败状态。</li></ul><h4 id="_3-promise、generator、async有什么区别" tabindex="-1">3.Promise、Generator、Async有什么区别？ <a class="header-anchor" href="#_3-promise、generator、async有什么区别" aria-label="Permalink to &quot;3.Promise、Generator、Async有什么区别？&quot;">​</a></h4><p>这三个函数其实都是异步解决方案，从左至右逐渐发展。把异步问题写的越来越优雅。</p><p>-&gt;Generator&lt;- 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><p>调用 -&gt;Generator&lt;- 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。下一步，必须调用遍历器对象的-&gt;next&lt;-方法，使得指针移向下一个状态。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#82AAFF;">fetch</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">yield</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">ajax</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">aaa</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">yield</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">ajax</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bbb</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">yield</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">ajax</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ccc</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> gen </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">fetch</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> res1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> gen</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;font-style:italic;">// { value: &#39;aaa&#39;, done: false }</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> res2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> gen</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;font-style:italic;">// { value: &#39;bbb&#39;, done: false }</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> res3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> gen</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;font-style:italic;">// { value: &#39;ccc&#39;, done: false }</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> res4 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> gen</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;font-style:italic;">// { value: undefined, done: true } done为true表示执行结束</span></span></code></pre></div><p>三种方案都是为解决传统的回调函数而提出的，所以它们相对于回调函数的优势不言而喻。而-&gt;async/await&lt;-又是-&gt;Generator&lt;-函数的语法糖。</p><ul><li>-&gt;Promise&lt;-的内部错误使用-&gt;try catch&lt;-捕获不到，只能只用-&gt;then&lt;-的第二个回调或-&gt;catch&lt;-来捕获，而-&gt;async/await&lt;-的错误可以用-&gt;try catch&lt;-捕获</li><li>-&gt;Promise&lt;-一旦新建就会立即执行，不会阻塞后面的代码，而-&gt;async&lt;-函数中-&gt;await&lt;-后面是-&gt;Promise&lt;-对象会阻塞后面的代码。</li><li>-&gt;async&lt;-函数会隐式地返回一个-&gt;promise&lt;-，该-&gt;promise&lt;-的-&gt;reosolve&lt;-值就是函数-&gt;return&lt;-的值。</li><li>-&gt;async&lt;-函数可以让代码更加简洁，不需要像-&gt;Promise&lt;-一样需要调用then方法来获取返回值，不需要写匿名函数处理-&gt;Promise&lt;-的-&gt;resolve&lt;-值，也不需要定义多余的data变量，还避免了嵌套代码。</li></ul><h4 id="_4-promise-all-传入的数组内可以有不是promise对象的吗" tabindex="-1">4.promise.all 传入的数组内可以有不是promise对象的吗？ <a class="header-anchor" href="#_4-promise-all-传入的数组内可以有不是promise对象的吗" aria-label="Permalink to &quot;4.promise.all 传入的数组内可以有不是promise对象的吗？&quot;">​</a></h4><p>可以的，不会报错也不会进入catch，会将值直接放入返回值内</p><h3 id="http请求" tabindex="-1">http请求 <a class="header-anchor" href="#http请求" aria-label="Permalink to &quot;http请求&quot;">​</a></h3><h4 id="_1-ajax的原理" tabindex="-1">1.ajax的原理 <a class="header-anchor" href="#_1-ajax的原理" aria-label="Permalink to &quot;1.ajax的原理&quot;">​</a></h4><p>就是通过<code>XMLHttpRequest</code>对象向服务器发送异步请求，从服务器获取数据，利用<code>js</code>来操作<code>DOM</code>更新页面。</p><h4 id="_2-ajax发送请求的过程" tabindex="-1">2.ajax发送请求的过程？ <a class="header-anchor" href="#_2-ajax发送请求的过程" aria-label="Permalink to &quot;2.ajax发送请求的过程？&quot;">​</a></h4><ul><li>1.创建<code>XMLHttpRequest</code>对象</li><li>2.调用<code>open</code>方法初始化HTTP请求参数（请求方法，url）</li><li><ul><li>如果是<code>post</code>请求，需要调用<code>setRequestHeader</code>方法设置请求头</li></ul></li><li>3.创建监听异步回调方法</li><li>4.调用<code>send</code>方法发送请求</li><li>5.获取请求返回值，根据返回状态执行相应操作</li></ul><h4 id="_3-ajax-fetch-axios有什么区别" tabindex="-1">3.ajax，fetch，axios有什么区别？ <a class="header-anchor" href="#_3-ajax-fetch-axios有什么区别" aria-label="Permalink to &quot;3.ajax，fetch，axios有什么区别？&quot;">​</a></h4><ul><li>ajax：是对原生xhr的封装，在JQuery时代常用</li><li>fetch：是xhr的替代品，是ES规范里面全新的实现方式，全新的底层实现。</li><li>axios：本质上也是对xhr的封装，但是是利用Promise封装的版本，符合最新的ES规范</li></ul><h3 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h3><h4 id="_1-设计模式是什么" tabindex="-1">1.设计模式是什么？ <a class="header-anchor" href="#_1-设计模式是什么" aria-label="Permalink to &quot;1.设计模式是什么？&quot;">​</a></h4><p>模式是一种可服用的解决方案，用于解决软件设计中遇到的常见问题。说白了就是套路，一种写代码的攻略。遇到相应的场景能够快速找到最好的解决方案。</p><h4 id="_2-前端有哪些常用的设计模式" tabindex="-1">2.前端有哪些常用的设计模式？ <a class="header-anchor" href="#_2-前端有哪些常用的设计模式" aria-label="Permalink to &quot;2.前端有哪些常用的设计模式？&quot;">​</a></h4><h5 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h5><p>要实现某一个功能，有多种方案可以选择。我们定义策略，把它们一个个封装起来，并且使它们可以相互转换</p><p>使用场景：权限判断，表单验证等等</p><h5 id="发布-订阅者模式" tabindex="-1">发布-订阅者模式 <a class="header-anchor" href="#发布-订阅者模式" aria-label="Permalink to &quot;发布-订阅者模式&quot;">​</a></h5><p>EventEmit</p><p>就是发布订阅者模式的一个管理中心，订阅者把自己想订阅的事件注册到管理中心，当发布者发布该事件的时候，也就是该事件触发的时候，由管理中心统一调度订阅者的注册代码</p><p>使用场景：各模块独立，且存在一对多的关系</p><h5 id="装饰器模式、适配器模式" tabindex="-1">装饰器模式、适配器模式 <a class="header-anchor" href="#装饰器模式、适配器模式" aria-label="Permalink to &quot;装饰器模式、适配器模式&quot;">​</a></h5><p>装饰器模式：就是指把一个原有的对象加上一些你想要加的功能，但并不改变原有的功能</p><p>适配器模式：就是解决不兼容的问题，比如一个苹果电脑没有usb接口，那么就要装上一个转接器来实现插u盘的功能</p><h3 id="不常见的运算" tabindex="-1">不常见的运算 <a class="header-anchor" href="#不常见的运算" aria-label="Permalink to &quot;不常见的运算&quot;">​</a></h3><h4 id="_1-null-undefined" tabindex="-1">1.null==undefined <a class="header-anchor" href="#_1-null-undefined" aria-label="Permalink to &quot;1.null==undefined&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><h4 id="_2-0-0" tabindex="-1">2.+0==-0 <a class="header-anchor" href="#_2-0-0" aria-label="Permalink to &quot;2.+0==-0&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">+</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">==-</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><h4 id="_3-typeof-nan" tabindex="-1">3.typeof NaN <a class="header-anchor" href="#_3-typeof-nan" aria-label="Permalink to &quot;3.typeof NaN&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">NaN</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// number</span></span></code></pre></div><h4 id="_4-typeof-null" tabindex="-1">4.typeof null <a class="header-anchor" href="#_4-typeof-null" aria-label="Permalink to &quot;4.typeof null&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// object</span></span></code></pre></div>`,138),t=[n];function p(r,c,i,d,h,y){return l(),s("div",null,t)}const A=a(o,[["render",p]]);export{D as __pageData,A as default};
