import{_ as t,c as a,o,V as e}from"./chunks/framework.f518e559.js";const q=JSON.parse('{"title":"微前端","description":"","frontmatter":{"title":"微前端","config":{"dir":true},"password":true},"headers":[],"relativePath":"views/interview/MicroFrontends.md"}'),i={name:"views/interview/MicroFrontends.md"},n=e('<h3 id="qiankun2-0" tabindex="-1">qiankun2.0 <a class="header-anchor" href="#qiankun2-0" aria-label="Permalink to &quot;qiankun2.0&quot;">​</a></h3><h4 id="_1-沙箱-是什么" tabindex="-1">1.&quot;沙箱&quot;是什么？ <a class="header-anchor" href="#_1-沙箱-是什么" aria-label="Permalink to &quot;1.&quot;沙箱&quot;是什么？&quot;">​</a></h4><p>沙箱 (Sandboxie) ，又叫沙盘，即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以随后删除。它创造了一个类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。 在网络安全中，沙箱指在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具</p><p>在qiankun里，其实就是解决微前端中的隔离问题，它实现了一个叫做-&gt;运行时沙箱&lt;-的东西</p><h4 id="_2-沙箱-是如何实现的" tabindex="-1">2.&quot;沙箱&quot;是如何实现的？ <a class="header-anchor" href="#_2-沙箱-是如何实现的" aria-label="Permalink to &quot;2.&quot;沙箱&quot;是如何实现的？&quot;">​</a></h4><p>简单来说，分为-&gt;js沙箱&lt;-、-&gt;样式沙箱&lt;-</p><h5 id="js沙箱" tabindex="-1">js沙箱 <a class="header-anchor" href="#js沙箱" aria-label="Permalink to &quot;js沙箱&quot;">​</a></h5><p>通过 -&gt;proxy&lt;- 代理 -&gt;window&lt;- 对象，记录 -&gt;window&lt;- 对象上属性的增删改查</p><ul><li>单例模式</li></ul><blockquote><p>直接代理了原生 window 对象，记录原生 window 对象的增删改查，当 window 对象激活时恢复 window 对象到上次即将失活时的状态，失活时恢复 window 对象到初始初始状态</p></blockquote><ul><li>多例模式</li></ul><blockquote><p>代理了一个全新的对象，这个对象是复制的 window 对象的一部分不可配置属性，所有的更改都是基于这个 fakeWindow 对象，从而保证多个实例之间属性互不影响</p></blockquote><p>将这个 -&gt;proxy&lt;- 作为微应用的全局对象，所有的操作都在这个 -&gt;proxy&lt;- 对象上，这就是 JS 沙箱的原理</p><h5 id="css沙箱" tabindex="-1">css沙箱 <a class="header-anchor" href="#css沙箱" aria-label="Permalink to &quot;css沙箱&quot;">​</a></h5><p>利用了-&gt;Shadow DOM&lt;-影子节点，可以将一个隐藏的、独立的 DOM 附加到一个元素上，一般来说是微应用的容器，以及运用了-&gt;Scoped CSS 隔离&lt;-来实现css沙箱（添加css属性）</p>',15),r=[n];function s(l,c,d,u,p,h){return o(),a("div",null,r)}const w=t(i,[["render",s]]);export{q as __pageData,w as default};
