import{_ as t,c as e,o as a,V as r}from"./chunks/framework.f518e559.js";const T=JSON.parse('{"title":"TypeScript","description":"","frontmatter":{"title":"TypeScript","config":{"dir":true},"password":true},"headers":[],"relativePath":"views/interview/TypeScript.md"}'),i={name:"views/interview/TypeScript.md"},s=r('<h3 id="typescript" tabindex="-1">TypeScript <a class="header-anchor" href="#typescript" aria-label="Permalink to &quot;TypeScript&quot;">​</a></h3><h4 id="_1-ts的原理-为什么会有ts" tabindex="-1">1.TS的原理？为什么会有TS？ <a class="header-anchor" href="#_1-ts的原理-为什么会有ts" aria-label="Permalink to &quot;1.TS的原理？为什么会有TS？&quot;">​</a></h4><p>ts就是js的超集，ts在js的基础上对数据类型进行约束产生的一种新语言，使得代码更加规范，相比于js来说，ts在攥写代码/编译过程中就能够发现错误，而防止在产品上线后发生一些莫名其妙的问题。</p><h4 id="_2-interface和type的区别是什么" tabindex="-1">2.interface和type的区别是什么？ <a class="header-anchor" href="#_2-interface和type的区别是什么" aria-label="Permalink to &quot;2.interface和type的区别是什么？&quot;">​</a></h4><p>两者的作用都是一样的，都是定义一个类型别名（接口），但是扩展接口的方式有所不同，-&gt;interface&lt;-可以用-&gt;extends&lt;-，-&gt;type&lt;-用-&gt;&amp;&lt;-，如果定义同名的接口，-&gt;interface&lt;-会合并两者，-&gt;type&lt;-不允许定义同名的类型别名</p>',5),c=[s];function p(n,o,_,l,d,h){return a(),e("div",null,c)}const S=t(i,[["render",p]]);export{T as __pageData,S as default};
