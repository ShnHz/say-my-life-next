---
title: 浏览器
config : {
    dir : true
}
password: true
---

### 浏览器

#### 1.说一说cookie、sessionStorage、localStorage？

+ cookie：容量小，约4kb左右，生命周期自定义，请求时可以自动携带，前后端都可以设置。
+ sessionStorage：容量大，约5MB左右，关闭页面后自动清除。
+ localStorage：容量大，约20MB左右，永久保存，需要手动删除。

#### 2.浏览器的垃圾回收机制

新时代

采用空间换时间的 scavenge 算法：整个空间分为两块，变量仅存在其中一块，回收的时候将存活变量复制到另一块空间，不存活的回收掉，周而复始轮流操作

旧时代

+ 标记清除：给全部活动变量打个标记，没有打标记的，到清除阶段则清除
+ 引用清除：当没有其他变量引用它时候则清除

#### 3.前端路由是什么？有哪几种实现方式

主要有两种

+ 1.hash模式，监听url#后的内容，执行相应操作，实现前端路由
+ 2.history模式，利用historyApi实现路由，重写history.pushState和history.replaceState来让popstate能够被触发

->hash<-：浏览器也有一个hashChange事件，监听这个事件，来渲染不同的组件代码。

+ hash模式所有的工作都是在前端完成的，不需要后端服务的配合
+ hash模式的实现方式就是通过监听URL中hash部分的变化，从而做出对应的渲染逻辑
+ hash模式下，URL中会带有#，看起来不太美观

->history<-：h5提供了一个history全局对象，这个对象里面有各种方法，而history路由的实现，主要就是依靠于pushState与replaceState实现的，是需要后端配合的，不然刷新页面会404

+ window.history.go 可以跳转到浏览器会话历史中的指定的某一个记录页
+ window.history.forward 指向浏览器会话历史中的下一页，跟浏览器的前进按钮相同
+ window.history.back 返回浏览器会话历史中的上一页，跟浏览器的回退按钮功能相同
+ window.history.pushState 可以将给定的数据压入到浏览器会话历史栈中
+ window.history.replaceState 将当前的会话页面的url替换成指定的数据

#### 4.小程序与传统网页的区别？

小程序其实是运行在一个微信团队或者说是企业应用内的一个基于浏览器内核创建的内置解析器里，而网页就是运行在浏览器内的

小程序对于开发者来说，兼容性问题其实可以不用太在意，因为例如微信团队会提供开发工具以及制定开发规范，但是网页运行的环境太多太杂，很容易出现兼容性问题

小程序对于硬件获取的权限比较充分，比如网络通信状态、数据缓存能力、硬件调用等等，但是浏览器环境没有这么充分的权限

#### 5.浏览器运行过程

+ 解析URL
+ 缓存判断
+ DNS解析
+ 获取MAC地址
+ TCP三次握手
+ HTTPS握手
+ 返回数据
+ 页面渲染
+ TCP四次挥手

#### 6.浏览器的缓存机制？

浏览器缓存主要分为**强缓存（也称本地缓存）**和**协商缓存（也称弱缓存）**

##### 强缓存：

当请求资源的时，如果是之前请求过的并使用强缓存，那么在过期时间内将不会发送本次请求向服务器获取资源，而是直接从浏览器缓存中获取（不管资源是否改动）。过期了将重新从服务器获取，并再次强缓存。

状态码：200
##### 协商缓存：

当请求资源时，如果是之前请求过的并使用协商缓存，还是发送请求到服务器，服务器通过逻辑判断确认资源没有修改返回304状态码，那么本次的资源则是从缓存中获取；如果经过判断确认资源被修改过，则重新发送资源到客户端，并且客户端更新缓存。

状态码：304

#### 7.浏览器的渲染过程

+ 构建DOM树
+ 样式计算，把 CSS 转换为浏览器能够理解的结构，并转换样式表中的属性值，使其标准化，生成CSSOM树（CSS规则树）
+ 结合DOM树以及CSSOM树生成render树
+ 解析完成，进行渲染

#### 8.css加载会造成阻塞吗

CSS 加载会阻塞 Dom 的渲染，DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。
然而,由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的,
所以他必须等待到 CSSOM Tree 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。

#### 9.如何监听浏览器返回事件,并且阻止返回

监听浏览器的popstate事件,在事件触发的时候向history内pushState一个当前页面，在点击后退前和点击时都插入一次，那样无论点前进还是后退永远都会留在这个页面了

### 安全攻击

#### 1.CSRF攻击是什么？如何防范？

跨站请求伪造，利用用户的已登录凭证来冒充用户攻击网站。

+ 利用验证码
+ Referer检查
+ 添加token验证

#### 2.XSS攻击是什么？如何防范？

跨站脚本注入，攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

+ 设置HttpOnly防止窃取Cookie
+ 输入检查，检查用户的输入项目是否存在有"<"、">"等特殊字符，如果存在就进行特殊编码处理
+ 输出检查，服务端返回的数值也可能存在问题

