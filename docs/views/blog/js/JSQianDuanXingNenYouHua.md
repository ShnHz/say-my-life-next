---
title: JS:前端性能优化
date: 2023/08/25 14:17:35
summary: 从代码纬度的一些运行速度上的优化项目
config: {
    show: true,
    top: false,
    dir: true,
    dirTag: ["h3","h4","h5"],
    tag: ["js"],
    valine: true,
    valineId: 
}
password: false
outline: [3,5]
---

:::info
可以在代码层面显著提高性能的一些小tip
:::

### 1. 合并数组

结论：具体结合实际场景使用， ->array.concat(array2)<-性能最好

| 代码 | 原理  |	结论 | 测试（两个一千万数据合并） |
|:--------|:--------|:---------:|:--------|
| array.push(...array2)| 这种方法通过将第二个数组中的每个元素依次添加到第一个数组中来合并两个数组。这种方法的性能较差是因为每个元素都要进行一次单独的添加操作，这会导致频繁的内存分配和数据的复制|性能较差|Maximum call stack size exceeded|
| [...array,...array2]|它会将数组 array 和 array2 中的元素解构开，然后再通过数组字面量 [...] 创建一个新的数组，但依然会产生一个新的数组并进行数据复制|性能一般|147.68505859375 ms|
| array.concat(array2)|concat 方法是在底层优化过的，它会直接将两个数组的引用合并，并创建一个新的数组对象。这样就避免了对每个元素进行复制的开销|性能最好|21.154296875 ms|

### 2. 数组循环

结论：具体结合实际场景使用， ->for (let i = 0,len = array.length; i < len; i++){}<-性能最好，->forEach<-可读性更强且性能也没有太大损失。

| 代码 | 原理  |	结论 | 测试（一千万数据） |
|:--------|:--------|:---------:|:--------|
| for(let i in array){}| 它不仅遍历了数组的指定元素，还遍历了数组中的所有可枚举属性，包括数组原型链上继承的可枚举属性。这意味着它会遍历一些不是数组元素的属性，导致额外的开销和性能损耗|性能较差|1299.587890625 ms|
|array.forEach(item=>{})|使用遍历器迭代数组元素，对每个元素执行指定的回调函数|性能一般|128.465087890625 ms|
| for(let i = 0;i<array.length;i++){} | 使用计数器控制循环次数，通过访问数组索引来访问和操作数组元素|性能一般|97.27001953125 ms|
| for (let i = 0,len = array.length; i < len; i++){} | 先获取数组的长度（len = array.length），然后使用计数器控制循环次数，通过访问数组索引来访问和操作数组元素|性能最好|74.547119140625 ms|

### 3. 数组去重

结论：使用->Set<-进行去重，可读性高且性能好

| 代码 | 原理  |	结论 | 测试（一千万数据） |
|:--------|:--------|:---------:|:--------|
| array.filter((value, index, self) => { return self.indexOf(value) === index })| |性能较差|3000.587890625 ms|
|array.reduce((result, current) => { if (!result.includes(current)) { result.push(current) } return result }, [])||性能较好|78.4130859375 ms|
| Object.keys( array.reduce((obj, value) => { obj[value] = true return obj }, {}) ) ||性能较好|68.533935546875 ms|
| [...new Set(array)] ||性能较好|57.843017578125 ms|
| Array.from(new Set(array)) |Set中的值是唯一的，Set内部使用类似于哈希表的数据结构，它可以快速查找和插入值，并且可以保持插入值的顺序|性能较好|57.778076171875 ms|

### 4. 深拷贝

结论：这些深拷贝方式都有各自的优缺点，应根据实际需求选择合适的方法。如果不需要处理循环引用和函数/原型链，使用 ->JSON 序列化和反序列化<-仍然是性能最佳的选择。

| 代码 | 原理  |	结论 | 测试（一千万数据） |
|:--------|:--------|:---------:|:--------|
| Object.assign()|当目标对象仅有一层数据时，可以使用 Object.assign() 进行浅拷贝，但需要注意，它在深拷贝复制时仍然会出现引用传递的问题。 |性能较差|2840.05126953125 ms|
| |递归复制：递归复制是指遍历对象的属性，并逐个复制每个属性的值。递归复制方法可以处理循环引用和函数/原型链|性能较差|1430.828125 ms|
| JSON.parse(JSON.stringify(array))||性能较好|473.587890625 ms|
| [...array]| 利用解构创建一个新数组进行深拷贝 |性能较好|228.509765625 ms|